---
title: "Extensiones del Modelo Regresión Lineal Múltiple"
author: "Juan Barriola, Azul Villanueva y Franco Mastelli"
date: "01 de Octubre de 2022"
output:
  html_document:
    toc: yes
    code_folding: show
    toc_float: yes
    df_print: paged
    theme: united
    code_download: yes
  html_notebook:
    theme: spacelab
    toc: yes
    toc_float: yes
    df_print: paged
---

<style type="text/css">
div.main-container {
  max-width: 1600px;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r, echo=FALSE}
options(scipen = 8)
```

```{r, warning=F, message=F}
library(tidyverse)
library(tidymodels)
library(gridExtra)
library(GGally)
library(corrplot)
library(corrr)
library(gridExtra)
library(MASS)
library(kableExtra)
library(janitor)
```

## Introducción




```{r}
#Cargo los datos
datos <- read.csv("eph_train_2023.csv")
```


## Análisis Exploratorio de datos



```{r}
#Variables numericas----
#Estructura de los datos
datos %>% glimpse()
#Quito años, trimesrte y fecha de nacimiento que no los voy a usar
datos <- datos[-c(2,3,6)]
datos$aglomerado <- as.factor(datos$aglomerado)
datos$codigo_actividad <- as.factor(datos$codigo_actividad)
```

```{r}
tabla_exploratorios =  datos %>%
  gather(., 
         key = "variables", 
         value = "valores") %>% # agrupamos por las variables del set
  group_by(variables) %>% 
  summarise(valores_unicos = n_distinct(valores),
            porcentaje_faltantes = sum(is.na(valores))/nrow(datos)*100) %>% 
  arrange(desc(porcentaje_faltantes), valores_unicos) # ordenamos por porcentaje de faltantes y valores unicos
tabla_exploratorios
#Saco ese único NA
datos <- subset(datos, !is.na(asistencia_educacion))
```


```{r}
# Boxplots de variables categorias que puedo utilizar en modelos
g1 <- ggplot(datos, aes(x=region, fill=region))+
  geom_bar()+
  theme_bw()+
  theme(legend.position = "none",axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(size = 8),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())+
  ggtitle("Distribución de trabajadores por región")

g2 <- ggplot(datos, aes(x=nivel_ed, fill=nivel_ed))+
  geom_bar()+
  theme_bw()+
  theme(legend.position = "none",axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(size = 8),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())+
  ggtitle("Distribución de trabajadores por nivel educativo")

g3 <- ggplot(datos, aes(x=tipo_establecimiento, fill=tipo_establecimiento))+
  geom_bar()+
  theme_bw()+
  theme(legend.position = "none",axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(size = 8),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())+
  ggtitle("Distribución de trabajadores por tipo de establecimiento")

g4 <- ggplot(datos, aes(x=categoria_ocupacion, fill=categoria_ocupacion))+
  geom_bar()+
  theme_bw()+
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(size = 8),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())+
  ggtitle("Distribución de trabajadores por puesto laboral")+
  scale_x_discrete(labels = c("Trabajador sin remuneracion" = "Sin salario"))
# grafico todos juntos
grid.arrange(g1, g2, g3, g4, nrow = 2)
```

```{r}
#Grafico de correlaciones
grafico1 <- datos %>%
  select_if(is.numeric) %>%
  ggpairs()

grafico1
```

```{r}
m_cor <- datos %>%
  select_if(is.numeric) %>%
  cor()
corrplot(m_cor,
         method="circle",
         type = "upper",
         addCoef.col = "black",
         diag= FALSE) 
```

```{r}
datos %>% 
  select_if(is.numeric) %>% # selecciona las variables numericas 
  correlate(method = 'spearman') %>% # convierte la matriz de corr en dataframe
  shave() %>% # solo muestra información debajo de la diagonal principal
  fashion(decimals = 3) # acomoda los datos en forma tidy (por ej. redondeo de decimales)
```

```{r}
grafico2 <- datos %>% 
  select_if(is.numeric) %>% 
  mutate(sexo = datos$sexo) %>%
  ggpairs(., mapping = aes(colour = sexo), title = "Matriz de correlaciones",
          upper = list(continuous = wrap("cor", size = 3, hjust=0.5)), legend = 25) + 
  theme_bw() +
  theme(axis.text.x = element_text(angle=45, vjust=0.5), legend.position = "bottom")

grafico2 #no veo inconsistencias severas en este gráfico
```

```{r}
#2)Modelos lineales experiencia----
ggplot(datos, aes(x=experiencia_potencial, y= salario_horario))+
  geom_point()+
  theme_bw()
```

```{r}
#No parece una relación muy lineal pero miremos el modelo: salario_horario vs exp_pot
modelo_simple_salhor_hr = lm(formula = salario_horario ~ experiencia_potencial, data = datos)
# Observamos que devuelve el modelo
tidy(modelo_simple_salhor_hr, conf.int = T)
```

```{r}
#Modelo salario_horario vs exp_pot + exp_pot^2
modelo_multiple_salhr_hr = lm(formula = salario_horario ~ experiencia_potencial + I(experiencia_potencial^2), data = datos)
# Observamos que devuelve el modelo
tidy(modelo_multiple_salhr_hr, conf.int = T)
```

```{r}
# Graficamos el dataset y los modelos
datos %>% ggplot(., aes(x = experiencia_potencial, y = salario_horario)) + 
  geom_point(color="grey") + #capa de los datos
  theme_bw() +
  geom_smooth(method = "lm", formula = y ~ x, color="forestgreen", se = FALSE) + # capa del modelo
  geom_smooth(method = "lm", formula = y ~ x + I(x^2), color = "red", se = FALSE) +  # Ajuste del modelo
  
  #scale_x_continuous(limits = c(0,65)) +
  #scale_y_continuous(limits = c(0,550000)) +
  labs(title="Modelo Lineal Simple: Salario Horario", x="Exp. Pot.", y="Salario Hora") 
```

```{r}
df_predicciones <- data.frame(experiencia_potencial=c(6,7,35,36))
df_predicciones$predicciones <- predict(modelo_multiple_salhr_hr,df_predicciones)

experiencia_6 <- df_predicciones$predicciones[2] - df_predicciones$predicciones[1]
experiencia_35 <- df_predicciones$predicciones[4] - df_predicciones$predicciones[3]

experiencia_6
experiencia_35
```


```{r}
#3) Modelo lineal multiple----
datos$sexo <- factor(datos$sexo)

modelo_mincer1 <- lm(formula = salario_horario ~ educacion + 
                       experiencia_potencial + 
                       I(experiencia_potencial^2) +
                       sexo +
                       sexo:educacion,
                     data=datos)
tidy(modelo_mincer1, conf.int = T)
```

```{r}
tidy(anova(modelo_mincer1))
```

```{r}
tidy_mincer1 <- tidy(modelo_mincer1, conf.int = TRUE) %>% arrange(p.value)
tidy_mincer1
```

```{r}
ggplot(tidy_mincer1, aes(estimate, term, xmin = conf.low, xmax = conf.high, height = 0)) +
  geom_point(color = "forestgreen",size=2) +
  geom_vline(xintercept = 0, lty = 4, color = "black") +
  geom_errorbarh(color = "forestgreen", size=1) +
  theme_bw() +
  labs(y = "Coeficientes β", x = "Estimación")
```

```{r}
datos_augmentados <- augment(modelo_mincer1)

g1 = ggplot(datos_augmentados, aes(.fitted, .resid)) +
  geom_point() +
  geom_hline(yintercept = 0) +
  geom_smooth(se = FALSE) +
  labs(title = "Residuos vs valores predichos") + 
  theme_bw()
g2 = ggplot(datos_augmentados, aes(sample = .std.resid)) +
  stat_qq() +
  geom_abline() +
  labs(title = "Normal QQ plot") + 
  theme_bw()
g3 = ggplot(datos_augmentados, aes(.fitted, sqrt(abs(.std.resid)))) +
  geom_point() +
  geom_smooth(se = FALSE) + 
  theme_bw() +
  labs(title = "Scale-location plot")
g4 = ggplot(datos_augmentados, aes(.hat, .std.resid)) +
  geom_vline(size = 2, colour = "white", xintercept = 0) +
  geom_hline(size = 2, colour = "white", yintercept = 0) +
  geom_point() + 
  geom_smooth(se = FALSE) + 
  theme_bw() +
  labs(title = "Residual vs leverage")
# grafico todos juntos
grid.arrange(g1, g2, g3, g4, nrow = 2)
```

```{r}
modelo_mincer2 <- lm(formula = log(salario_horario) ~ educacion + 
                       experiencia_potencial + 
                       I(experiencia_potencial^2) +
                       sexo +
                       sexo:educacion,
                     data=datos)
tidy(anova(modelo_mincer2))
```

```{r}
tidy_mincer2 <- tidy(modelo_mincer2, conf.int = TRUE) %>% arrange(p.value)
tidy_mincer2
```

```{r}
ggplot(tidy_mincer2, aes(estimate, term, xmin = conf.low, xmax = conf.high, height = 0)) +
  geom_point(color = "forestgreen",size=2) +
  geom_vline(xintercept = 0, lty = 4, color = "black") +
  geom_errorbarh(color = "forestgreen", size=1) +
  theme_bw() +
  labs(y = "Coeficientes β", x = "Estimación")
```

```{r}
#Uso augment para calcular las variables necesarios para hacer los gráficos con ggplot
datos_augmentados <- augment(modelo_mincer2)

g1 = ggplot(datos_augmentados, aes(.fitted, .resid)) +
  geom_point() +
  geom_hline(yintercept = 0) +
  geom_smooth(se = FALSE) +
  labs(title = "Residuos vs valores predichos") + 
  theme_bw()
g2 = ggplot(datos_augmentados, aes(sample = .std.resid)) +
  stat_qq() +
  geom_abline() +
  labs(title = "Normal QQ plot") + 
  theme_bw()
g3 = ggplot(datos_augmentados, aes(.fitted, sqrt(abs(.std.resid)))) +
  geom_point() +
  geom_smooth(se = FALSE) + 
  theme_bw() +
  labs(title = "Scale-location plot")
g4 = ggplot(datos_augmentados, aes(.hat, .std.resid)) +
  geom_vline(size = 2, colour = "white", xintercept = 0) +
  geom_hline(size = 2, colour = "white", yintercept = 0) +
  geom_point() + 
  geom_smooth(se = FALSE) + 
  theme_bw() +
  labs(title = "Residual vs leverage")
# grafico todos juntos
grid.arrange(g1, g2, g3, g4, nrow = 2)
```

```{r}
# Predicciones en el logaritmo del salario
pred_log_salario <- predict(modelo_mincer2)

# Convertir las predicciones al salario horario original (inverso del logaritmo)
pred_salario <- exp(pred_log_salario)

# Salario horario observado (original)
salario_observado <- datos$salario_horario

# Calcular el R^2 corregido
r2_salario <- 1 - sum((salario_observado - pred_salario)^2) / sum((salario_observado - mean(salario_observado))^2)

print(r2_salario)
```

```{r}
#5)Modelos propios y evaluacion----

#Modelo propio 1----
modelo_propio1 <- lm(formula = log(salario_horario) ~ educacion +
                                     region +
                                     experiencia_potencial,
                                   data = datos)
tidy(anova(modelo_propio1))
```

```{r}
tidy_modelo_propio1 <- tidy(modelo_propio1, conf.int = TRUE) %>% arrange(p.value)
tidy_modelo_propio1
```


```{r}
#Uso augment para calcular las variables necesarios para hacer los gráficos con ggplot
datos_augmentados <- augment(modelo_propio1)

g1 = ggplot(datos_augmentados, aes(.fitted, .resid)) +
  geom_point() +
  geom_hline(yintercept = 0) +
  geom_smooth(se = FALSE) +
  labs(title = "Residuos vs valores predichos") + 
  theme_bw()
g2 = ggplot(datos_augmentados, aes(sample = .std.resid)) +
  stat_qq() +
  geom_abline() +
  labs(title = "Normal QQ plot") + 
  theme_bw()
g3 = ggplot(datos_augmentados, aes(.fitted, sqrt(abs(.std.resid)))) +
  geom_point() +
  geom_smooth(se = FALSE) + 
  theme_bw() +
  labs(title = "Scale-location plot")
g4 = ggplot(datos_augmentados, aes(.hat, .std.resid)) +
  geom_vline(size = 2, colour = "white", xintercept = 0) +
  geom_hline(size = 2, colour = "white", yintercept = 0) +
  geom_point() + 
  geom_smooth(se = FALSE) + 
  theme_bw() +
  labs(title = "Residual vs leverage")
# grafico todos juntos
grid.arrange(g1, g2, g3, g4, nrow = 2)
```

```{r}
# Predicciones en el logaritmo del salario
pred_log_salario <- predict(modelo_propio1)

# Convertir las predicciones al salario horario original (inverso del logaritmo)
pred_salario <- exp(pred_log_salario)

# Salario horario observado (original)
salario_observado <- datos$salario_horario

# Calcular el R^2 corregido
r2_salario <- 1 - sum((salario_observado - pred_salario)^2) / sum((salario_observado - mean(salario_observado))^2)

print(r2_salario) 
```

```{r}
#Modelo propio 2----
modelo_propio2 <- lm(formula = log(salario_horario) ~ edad/experiencia_potencial +
                                     sexo:experiencia_potencial + tipo_establecimiento,
                     data = datos)
tidy(anova(modelo_propio2))
```

```{r}
tidy_modelo_propio2 <- tidy(modelo_propio2, conf.int = TRUE) %>% arrange(p.value)
tidy_modelo_propio2
```


```{r}
#Uso augment para calcular las variables necesarios para hacer los gráficos con ggplot
datos_augmentados <- augment(modelo_propio2)

g1 = ggplot(datos_augmentados, aes(.fitted, .resid)) +
  geom_point() +
  geom_hline(yintercept = 0) +
  geom_smooth(se = FALSE) +
  labs(title = "Residuos vs valores predichos") + 
  theme_bw()
g2 = ggplot(datos_augmentados, aes(sample = .std.resid)) +
  stat_qq() +
  geom_abline() +
  labs(title = "Normal QQ plot") + 
  theme_bw()
g3 = ggplot(datos_augmentados, aes(.fitted, sqrt(abs(.std.resid)))) +
  geom_point() +
  geom_smooth(se = FALSE) + 
  theme_bw() +
  labs(title = "Scale-location plot")
g4 = ggplot(datos_augmentados, aes(.hat, .std.resid)) +
  geom_vline(size = 2, colour = "white", xintercept = 0) +
  geom_hline(size = 2, colour = "white", yintercept = 0) +
  geom_point() + 
  geom_smooth(se = FALSE) + 
  theme_bw() +
  labs(title = "Residual vs leverage")
# grafico todos juntos
grid.arrange(g1, g2, g3, g4, nrow = 2)
```

```{r}
# Predicciones en el logaritmo del salario
pred_log_salario <- predict(modelo_propio1)

# Convertir las predicciones al salario horario original (inverso del logaritmo)
pred_salario <- exp(pred_log_salario)

# Salario horario observado (original)
salario_observado <- datos$salario_horario

# Calcular el R^2 corregido
r2_salario <- 1 - sum((salario_observado - pred_salario)^2) / sum((salario_observado - mean(salario_observado))^2)

print(r2_salario)
```

```{r}
#testeo----
test <- read.csv("eph_test_2023.csv")

pred_modelo_propio1 <- augment(modelo_propio1, newdata = test)
pred_modelo_propio1$exp_fitted <- exp(pred_modelo_propio1$.fitted)

pred_modelo_mincer1 <- augment(modelo_mincer1, newdata = test)

pred_modelo_mincer2 <- augment(modelo_mincer2, newdata = test)
pred_modelo_mincer2$exp_fitted <- exp(pred_modelo_mincer2$.fitted)

pred_modelo_propio2 <- augment(modelo_propio2, newdata = test)
pred_modelo_propio2$exp_fitted <- exp(pred_modelo_propio2$.fitted)
library(janitor)
# Calcular las métricas
metrics <- tibble(
  Model = c("Modelo Propio 1", "Modelo Mincer 1", "Modelo Mincer 2", "Modelo Propio 2"),
  RMSE = c(
    rmse(data = pred_modelo_propio1, truth = salario_horario, estimate = exp_fitted)$.estimate,
    rmse(data = pred_modelo_mincer1, truth = salario_horario, estimate = .fitted)$.estimate,
    rmse(data = pred_modelo_mincer2, truth = salario_horario, estimate = exp_fitted)$.estimate,
    rmse(data = pred_modelo_propio2, truth = salario_horario, estimate = exp_fitted)$.estimate
  ),
  MAE = c(
    mae(data = pred_modelo_propio1, truth = salario_horario, estimate = exp_fitted)$.estimate,
    mae(data = pred_modelo_mincer1, truth = salario_horario, estimate = .fitted)$.estimate,
    mae(data = pred_modelo_mincer2, truth = salario_horario, estimate = exp_fitted)$.estimate,
    mae(data = pred_modelo_propio2, truth = salario_horario, estimate = exp_fitted)$.estimate
  )
)

# Opcional: Limpiar los nombres de las columnas
metrics <- clean_names(metrics)

# Mostrar la tabla
print(metrics)
```