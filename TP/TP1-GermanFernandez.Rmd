---
title: "Trabajo Práctico Nº1"
author: "J. Germán Fernández"
date: "19 de Octubre de 2024"
subtitle: "Enfoque Estadístico del Aprendizaje"
output:
  html_document:
    toc: yes
    code_folding: show
    toc_float: yes
    df_print: paged
    theme: united
    code_download: yes
  html_notebook:
    theme: spacelab
    toc: yes
    toc_float: yes
    df_print: paged
---

<style type="text/css">
div.main-container {
  max-width: 1600px;
  margin-left: auto;
  margin-right: auto;
}
</style>



```{r, echo=FALSE}
options(scipen = 8)
```

```{r, warning=F, message=F}
library(tidyverse)
library(tidymodels)
library(gridExtra)
library(GGally)
library(corrplot)
library(corrr)
library(gridExtra)
library(MASS)
library(kableExtra)
library(janitor)
```


# Introducción

El objetivo del presente trabajo es predecir mediante modelos lineales simples y múltiples el salario por hora de los trabajadores de la República Argentina y encontrar cual sería el mejor modelo que explique esa variabilidad.

Para lograr estos objetivos utilzaremos un muestreo de la Encuesta Permanente de Hogares del tercer trimestre del año 2023. La cual ya se encuentra particionado en Entrenamiento y Prueba.


```{r}
#Cargo los datos
datos <- read.csv("eph_train_2023.csv")
```


# Análisis Exploratorio de datos

En primer lugar se realiza una análisis explotarios de datos para comprender que datos tenemos y como se comportan.

La siguiente tabla muestra los tipos de variables y algunos datos de ellas.

```{r}
#Variables numericas----
#Estructura de los datos
datos %>% glimpse()
```

```{r}
#Quito años, trimesrte y fecha de nacimiento que no los voy a usar
#datos <- datos[-c(2,3,6)]
datos$aglomerado <- as.factor(datos$aglomerado)
datos$codigo_actividad <- as.factor(datos$codigo_actividad)
datos <- datos[-c(2,3,6)]
```

Se eliminan las variables año y trimestre ya que es la misma para todos los datos, y la variable fecha de nacimento ya que sería redundante y seguramente correlacione altamente con la edad de los individuos, además viendo los dos primero datos se percibe que no están bien ingresados.

En la siguiente table se ven los datos faltantes. Se observa que hay un bajo porcentaje de datos faltantes solo en asistencia_educacion, se decide eliminar ese único dato.
```{r}
tabla_exploratorios =  datos %>%
  gather(., 
         key = "variables", 
         value = "valores") %>% # agrupamos por las variables del set
  group_by(variables) %>% 
  summarise(valores_unicos = n_distinct(valores),
            porcentaje_faltantes = sum(is.na(valores))/nrow(datos)*100) %>% 
  arrange(desc(porcentaje_faltantes), valores_unicos) # ordenamos por porcentaje de faltantes y valores unicos
tabla_exploratorios
#Saco ese único NA
datos <- subset(datos, !is.na(asistencia_educacion))
```

## Variables categóricas

Los siguientes gráficos de barras muestras la distribución de algunas de las variables categóricas que podría llegar a tener en consideración para el diseño de los modelos de predicción ya que creemos que podrían tener influencia en el salario de los trabajadores.

```{r}
# Boxplots de variables categorias que puedo utilizar en modelos
g1 <- ggplot(datos, aes(x=region, fill=region))+
  geom_bar()+
  theme_bw()+
  theme(legend.position = "none",axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(size = 8),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())+
  ggtitle("Distribución de trabajadores por región")

g2 <- ggplot(datos, aes(x=nivel_ed, fill=nivel_ed))+
  geom_bar()+
  theme_bw()+
  theme(legend.position = "none",axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(size = 8),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())+
  ggtitle("Distribución de trabajadores por nivel educativo")

g3 <- ggplot(datos, aes(x=tipo_establecimiento, fill=tipo_establecimiento))+
  geom_bar()+
  theme_bw()+
  theme(legend.position = "none",axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(size = 8),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())+
  ggtitle("Distribución de trabajadores por tipo de establecimiento")

g4 <- ggplot(datos, aes(x=categoria_ocupacion, fill=categoria_ocupacion))+
  geom_bar()+
  theme_bw()+
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(size = 8),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())+
  ggtitle("Distribución de trabajadores por puesto laboral")+
  scale_x_discrete(labels = c("Trabajador sin remuneracion" = "Sin salario"))
# grafico todos juntos
grid.arrange(g1, g2, g3, g4, nrow = 2)
```

## Variables numéricas

En el siguiente gráfico se puede observar los gráficos de dispersión de todas las variables numéricas y sus correlaciones.

Las variables experiencia potencial y edad están altamente correlacionadas positivamente, salario y salario por hora también pero en menor medidad.

Entre Experiencia potencial y educación se observa una ligera correlación negativa, mientras que entre salario y salario hora contra educación la correlación es ligamente positiva.

En el resto de las variables no ser pericibe correlación alguna.

```{r}
#Grafico de correlaciones
grafico1 <- datos %>%
  select_if(is.numeric) %>%
  ggpairs()

grafico1
```

En el siguiente gráfico de correlaciones se pueden apreciar mejor las relaciones entre variables previamente descriptas.

```{r}
m_cor <- datos %>%
  select_if(is.numeric) %>%
  cor()
corrplot(m_cor,
         method="circle",
         type = "upper",
         addCoef.col = "black",
         diag= FALSE) 
```

```{r}
#datos %>% 
#  select_if(is.numeric) %>% # selecciona las variables numericas 
#  correlate(method = 'spearman') %>% # convierte la matriz de corr en dataframe
#  shave() %>% # solo muestra información debajo de la diagonal principal
#  fashion(decimals = 3) # acomoda los datos en forma tidy (por ej. redondeo de decimales)
```

El siguiente gráfico muestra las correlaciones pero haciendo una apertura por sexo.

Se observa que según el sexo las correlaciones se mantienen. Sin embargo, se observa que los valores del coeficiente de correlacion de Pearson de todas las variables contra Salario por hora son ligaramente mayores en hombre, salvo en el caso de educación donde el coeficiente de correlacion es favorable para las muejeres.

```{r}
grafico2 <- datos %>% 
  select_if(is.numeric) %>% 
  mutate(sexo = datos$sexo) %>%
  ggpairs(., mapping = aes(colour = sexo), title = "Matriz de correlaciones",
          upper = list(continuous = wrap("cor", size = 3, hjust=0.5)), legend = 25) + 
  theme_bw() +
  theme(axis.text.x = element_text(angle=45, vjust=0.5), legend.position = "bottom")

grafico2 #no veo inconsistencias severas en este gráfico
```

# Modelos

## Primero modelo lineal

El primer modelo lineal consiste en explicar el Salario por Hora según la variable Eperiencia Potencial.

Primero graficamos las dos variables.

```{r}
#2)Modelos lineales experiencia----
ggplot(datos, aes(x=experiencia_potencial, y= salario_horario))+
  geom_point()+
  labs(title = "Experiencia Potencial vs Salario por Hora", x= "Experiencia Potencial", y="Salario por hora")+
  theme_bw()
```

Parecería observarse un aumento del salario a medida que aumenta la Experiencia Potencial pero llegada una edad entre 35 y 40 años de Experiencia Potencial el salario por hora parece empezar a disminuir.

Veamos como explica esto un modelo lineal simple del siguiente estilo:

E(SalarioHorario) = β0 + β1*ExperienciaPotencial

Con este modelo queremos inferir β1 y verificar si la relacion entre la variable independiente y la variable a explicar es estadísticamente significativa mediantes el siguiente test de hiótesis:

H0: β1=0
 
H1: β1≠0

```{r}
#No parece una relación muy lineal pero miremos el modelo: salario_horario vs exp_pot
modelo_simple_salhor_hr = lm(formula = salario_horario ~ experiencia_potencial, data = datos)
# Observamos que devuelve el modelo
summary(modelo_simple_salhor_hr)
```

Este modelo nos dice que el salario por hora aumenta $2,37 por cada año adicional de Experiencia Potencial y que β1 es distinto de cero, ya que el p-valor < 0,05, por lo tanto esa variable es significativa para explicar la variación del Salario por Hora.

Sin embargo, este modelo explica solo un 0,1% de la variabilidad.

Ajustamos otro modelo un poco mas complejo:

E(SalarioHorario) = β0 + β1*ExperienciaP otencial + β2*Experiencia Potencial^2

Este modelo puede que sea mas explicativo de la disminución que se observa gráficamente del Salario por Hora a partir de una determinada Experiencia Potencial.

```{r}
#Modelo salario_horario vs exp_pot + exp_pot^2
modelo_multiple_salhr_hr = lm(formula = salario_horario ~ experiencia_potencial + I(experiencia_potencial^2), data = datos)
# Observamos que devuelve el modelo
summary(modelo_multiple_salhr_hr)

```

En este modelo vamos que el p-valor de ambos coeficientes es menor a 0,05, por lo tanto ambos son significativos para explicar el Salario por Hora, pero también vemos que el coeficente de $ExperienciaPotencial^2$ tiene a dismnuir el salario a medida que aumenta la Experiencia Potencial.

Veamos este comportamiento graficando las curvas de ambos modelos, donde la curva roja es el modelo mas simple y la curva el mas complejo.


```{r}
# Graficamos el dataset y los modelos
datos %>% ggplot(., aes(x = experiencia_potencial, y = salario_horario)) + 
  geom_point(color="grey") + #capa de los datos
  theme_bw() +
  geom_smooth(method = "lm", formula = y ~ x, color="forestgreen", se = FALSE) + # capa del modelo
  geom_smooth(method = "lm", formula = y ~ x + I(x^2), color = "red", se = FALSE) +  # Ajuste del modelo
  
  #scale_x_continuous(limits = c(0,65)) +
  #scale_y_continuous(limits = c(0,550000)) +
  labs(title="Modelo Lineal Simple: Salario Horario", x="Experiencia Potencial", y="Salario Hora") 
```

```{r}
df_predicciones <- data.frame(experiencia_potencial=c(6,7,35,36))
df_predicciones$predicciones <- predict(modelo_multiple_salhr_hr,df_predicciones)

experiencia_6 <- df_predicciones$predicciones[2] - df_predicciones$predicciones[1]
experiencia_35 <- df_predicciones$predicciones[4] - df_predicciones$predicciones[3]

experiencia_6
experiencia_35
```


```{r}
#3) Modelo lineal multiple----
datos$sexo <- factor(datos$sexo)

modelo_mincer1 <- lm(formula = salario_horario ~ educacion + 
                       experiencia_potencial + 
                       I(experiencia_potencial^2) +
                       sexo +
                       sexo:educacion,
                     data=datos)
tidy(modelo_mincer1, conf.int = T)
```

```{r}
tidy(anova(modelo_mincer1))
```

```{r}
tidy_mincer1 <- tidy(modelo_mincer1, conf.int = TRUE) %>% arrange(p.value)
tidy_mincer1
```

```{r}
ggplot(tidy_mincer1, aes(estimate, term, xmin = conf.low, xmax = conf.high, height = 0)) +
  geom_point(color = "forestgreen",size=2) +
  geom_vline(xintercept = 0, lty = 4, color = "black") +
  geom_errorbarh(color = "forestgreen", size=1) +
  theme_bw() +
  labs(y = "Coeficientes β", x = "Estimación")
```

```{r}
datos_augmentados <- augment(modelo_mincer1)

g1 = ggplot(datos_augmentados, aes(.fitted, .resid)) +
  geom_point() +
  geom_hline(yintercept = 0) +
  geom_smooth(se = FALSE) +
  labs(title = "Residuos vs valores predichos") + 
  theme_bw()
g2 = ggplot(datos_augmentados, aes(sample = .std.resid)) +
  stat_qq() +
  geom_abline() +
  labs(title = "Normal QQ plot") + 
  theme_bw()
g3 = ggplot(datos_augmentados, aes(.fitted, sqrt(abs(.std.resid)))) +
  geom_point() +
  geom_smooth(se = FALSE) + 
  theme_bw() +
  labs(title = "Scale-location plot")
g4 = ggplot(datos_augmentados, aes(.hat, .std.resid)) +
  geom_vline(size = 2, colour = "white", xintercept = 0) +
  geom_hline(size = 2, colour = "white", yintercept = 0) +
  geom_point() + 
  geom_smooth(se = FALSE) + 
  theme_bw() +
  labs(title = "Residual vs leverage")
# grafico todos juntos
grid.arrange(g1, g2, g3, g4, nrow = 2)
```

```{r}
modelo_mincer2 <- lm(formula = log(salario_horario) ~ educacion + 
                       experiencia_potencial + 
                       I(experiencia_potencial^2) +
                       sexo +
                       sexo:educacion,
                     data=datos)
tidy(anova(modelo_mincer2))
```

```{r}
tidy_mincer2 <- tidy(modelo_mincer2, conf.int = TRUE) %>% arrange(p.value)
tidy_mincer2
```

```{r}
ggplot(tidy_mincer2, aes(estimate, term, xmin = conf.low, xmax = conf.high, height = 0)) +
  geom_point(color = "forestgreen",size=2) +
  geom_vline(xintercept = 0, lty = 4, color = "black") +
  geom_errorbarh(color = "forestgreen", size=1) +
  theme_bw() +
  labs(y = "Coeficientes β", x = "Estimación")
```

```{r}
#Uso augment para calcular las variables necesarios para hacer los gráficos con ggplot
datos_augmentados <- augment(modelo_mincer2)

g1 = ggplot(datos_augmentados, aes(.fitted, .resid)) +
  geom_point() +
  geom_hline(yintercept = 0) +
  geom_smooth(se = FALSE) +
  labs(title = "Residuos vs valores predichos") + 
  theme_bw()
g2 = ggplot(datos_augmentados, aes(sample = .std.resid)) +
  stat_qq() +
  geom_abline() +
  labs(title = "Normal QQ plot") + 
  theme_bw()
g3 = ggplot(datos_augmentados, aes(.fitted, sqrt(abs(.std.resid)))) +
  geom_point() +
  geom_smooth(se = FALSE) + 
  theme_bw() +
  labs(title = "Scale-location plot")
g4 = ggplot(datos_augmentados, aes(.hat, .std.resid)) +
  geom_vline(size = 2, colour = "white", xintercept = 0) +
  geom_hline(size = 2, colour = "white", yintercept = 0) +
  geom_point() + 
  geom_smooth(se = FALSE) + 
  theme_bw() +
  labs(title = "Residual vs leverage")
# grafico todos juntos
grid.arrange(g1, g2, g3, g4, nrow = 2)
```

```{r}
# Predicciones en el logaritmo del salario
pred_log_salario <- predict(modelo_mincer2)

# Convertir las predicciones al salario horario original (inverso del logaritmo)
pred_salario <- exp(pred_log_salario)

# Salario horario observado (original)
salario_observado <- datos$salario_horario

# Calcular el R^2 corregido
r2_salario <- 1 - sum((salario_observado - pred_salario)^2) / sum((salario_observado - mean(salario_observado))^2)

print(r2_salario)
```

```{r}
#5)Modelos propios y evaluacion----

#Modelo propio 1----
modelo_propio1 <- lm(formula = log(salario_horario) ~ educacion +
                                     region +
                                     experiencia_potencial,
                                   data = datos)
tidy(anova(modelo_propio1))
```

```{r}
tidy_modelo_propio1 <- tidy(modelo_propio1, conf.int = TRUE) %>% arrange(p.value)
tidy_modelo_propio1
```


```{r}
#Uso augment para calcular las variables necesarios para hacer los gráficos con ggplot
datos_augmentados <- augment(modelo_propio1)

g1 = ggplot(datos_augmentados, aes(.fitted, .resid)) +
  geom_point() +
  geom_hline(yintercept = 0) +
  geom_smooth(se = FALSE) +
  labs(title = "Residuos vs valores predichos") + 
  theme_bw()
g2 = ggplot(datos_augmentados, aes(sample = .std.resid)) +
  stat_qq() +
  geom_abline() +
  labs(title = "Normal QQ plot") + 
  theme_bw()
g3 = ggplot(datos_augmentados, aes(.fitted, sqrt(abs(.std.resid)))) +
  geom_point() +
  geom_smooth(se = FALSE) + 
  theme_bw() +
  labs(title = "Scale-location plot")
g4 = ggplot(datos_augmentados, aes(.hat, .std.resid)) +
  geom_vline(size = 2, colour = "white", xintercept = 0) +
  geom_hline(size = 2, colour = "white", yintercept = 0) +
  geom_point() + 
  geom_smooth(se = FALSE) + 
  theme_bw() +
  labs(title = "Residual vs leverage")
# grafico todos juntos
grid.arrange(g1, g2, g3, g4, nrow = 2)
```

```{r}
# Predicciones en el logaritmo del salario
pred_log_salario <- predict(modelo_propio1)

# Convertir las predicciones al salario horario original (inverso del logaritmo)
pred_salario <- exp(pred_log_salario)

# Salario horario observado (original)
salario_observado <- datos$salario_horario

# Calcular el R^2 corregido
r2_salario <- 1 - sum((salario_observado - pred_salario)^2) / sum((salario_observado - mean(salario_observado))^2)

print(r2_salario) 
```

```{r}
#Modelo propio 2----
modelo_propio2 <- lm(formula = log(salario_horario) ~ edad/experiencia_potencial +
                                     sexo:experiencia_potencial + tipo_establecimiento,
                     data = datos)
tidy(anova(modelo_propio2))
```

```{r}
tidy_modelo_propio2 <- tidy(modelo_propio2, conf.int = TRUE) %>% arrange(p.value)
tidy_modelo_propio2
```


```{r}
#Uso augment para calcular las variables necesarios para hacer los gráficos con ggplot
datos_augmentados <- augment(modelo_propio2)

g1 = ggplot(datos_augmentados, aes(.fitted, .resid)) +
  geom_point() +
  geom_hline(yintercept = 0) +
  geom_smooth(se = FALSE) +
  labs(title = "Residuos vs valores predichos") + 
  theme_bw()
g2 = ggplot(datos_augmentados, aes(sample = .std.resid)) +
  stat_qq() +
  geom_abline() +
  labs(title = "Normal QQ plot") + 
  theme_bw()
g3 = ggplot(datos_augmentados, aes(.fitted, sqrt(abs(.std.resid)))) +
  geom_point() +
  geom_smooth(se = FALSE) + 
  theme_bw() +
  labs(title = "Scale-location plot")
g4 = ggplot(datos_augmentados, aes(.hat, .std.resid)) +
  geom_vline(size = 2, colour = "white", xintercept = 0) +
  geom_hline(size = 2, colour = "white", yintercept = 0) +
  geom_point() + 
  geom_smooth(se = FALSE) + 
  theme_bw() +
  labs(title = "Residual vs leverage")
# grafico todos juntos
grid.arrange(g1, g2, g3, g4, nrow = 2)
```

```{r}
# Predicciones en el logaritmo del salario
pred_log_salario <- predict(modelo_propio1)

# Convertir las predicciones al salario horario original (inverso del logaritmo)
pred_salario <- exp(pred_log_salario)

# Salario horario observado (original)
salario_observado <- datos$salario_horario

# Calcular el R^2 corregido
r2_salario <- 1 - sum((salario_observado - pred_salario)^2) / sum((salario_observado - mean(salario_observado))^2)

print(r2_salario)
```

```{r}
#testeo----
test <- read.csv("eph_test_2023.csv")

pred_modelo_propio1 <- augment(modelo_propio1, newdata = test)
pred_modelo_propio1$exp_fitted <- exp(pred_modelo_propio1$.fitted)

pred_modelo_mincer1 <- augment(modelo_mincer1, newdata = test)

pred_modelo_mincer2 <- augment(modelo_mincer2, newdata = test)
pred_modelo_mincer2$exp_fitted <- exp(pred_modelo_mincer2$.fitted)

pred_modelo_propio2 <- augment(modelo_propio2, newdata = test)
pred_modelo_propio2$exp_fitted <- exp(pred_modelo_propio2$.fitted)
library(janitor)
# Calcular las métricas
metrics <- tibble(
  Model = c("Modelo Propio 1", "Modelo Mincer 1", "Modelo Mincer 2", "Modelo Propio 2"),
  RMSE = c(
    rmse(data = pred_modelo_propio1, truth = salario_horario, estimate = exp_fitted)$.estimate,
    rmse(data = pred_modelo_mincer1, truth = salario_horario, estimate = .fitted)$.estimate,
    rmse(data = pred_modelo_mincer2, truth = salario_horario, estimate = exp_fitted)$.estimate,
    rmse(data = pred_modelo_propio2, truth = salario_horario, estimate = exp_fitted)$.estimate
  ),
  MAE = c(
    mae(data = pred_modelo_propio1, truth = salario_horario, estimate = exp_fitted)$.estimate,
    mae(data = pred_modelo_mincer1, truth = salario_horario, estimate = .fitted)$.estimate,
    mae(data = pred_modelo_mincer2, truth = salario_horario, estimate = exp_fitted)$.estimate,
    mae(data = pred_modelo_propio2, truth = salario_horario, estimate = exp_fitted)$.estimate
  )
)

# Opcional: Limpiar los nombres de las columnas
metrics <- clean_names(metrics)

# Mostrar la tabla
print(metrics)
```